# Какими скилами должен обладать фронтендер

> «Любой дурак может написать код, понятный компьютеру. Хороший программист пишет код, понятный человеку»

_Мартин Фаулер_

Сравнение позиций среди разных Айти компаний [levels.fyi](https://www.levels.fyi/)

Джун
----

Что такое джун – понятие растяжимое, в одних компаниях это человек с опытом программирования, в других – вообще не смотрят на опыт и учат с нуля. Некоторые говорят что чел без опыта зовётся интерн или стажёр. Некоторые берут всех без разбора.

В двух словах джун это кому говорят “**Сделай это вот таким вот способом**”.

Минимальный юнит, способный писать код. Знает синтаксис языка и основы программирования типа циклов-условий-массивов. Если дать ему задачу и объяснить что и куда программировать — справится.

Компаниям джуны не особо нужны, потому что времени сеньоров они тратят больше, чем приносят пользы. Но их всё равно берут делать всякое говно за копейки, которое больше никто в команде не хочет пилить. Это называется «практика» или «стажировка».

**Самое важное на этом этапе:** научиться писать код.  
**Продолжительность:** 2-3 года.  
**Книги для продвижения дальше:** любые, в названии которых есть Яваскрипт. Плюс «[**Совершенный Код**](https://www.google.com/search?newwindow=1&client=safari&rls=en&ei=N2o7XJ-dGtDmsAeg5rHABQ&q=%D0%A1%D0%BE%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9+%D0%9A%D0%BE%D0%B4&oq=%D0%A1%D0%BE%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9+%D0%9A%D0%BE%D0%B4)», Кормен «[**Алгоритмы**](https://www.google.com/search?client=safari&rls=en&q=%D0%BA%D0%BE%D1%80%D0%BC%D0%B5%D0%BD+%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B&ie=UTF-8&oe=UTF-8)» и любые, чья обложка нравится.

Для фронта он должен знать:

*   бравзер Хром, и примерно какие-то другие (ФФ, Сафари, Эдж)
    *   как работать с DevTools, как смотреть участки кода и разметки
    *   основные понятия о дебагере в бравзере (JS и CSS)
*   основные селекторы CSS и немножко из современных возможностей: флексы, гриды. (Это фронт, а для верстака конечно всё более глубоко. Не забываем что в некоторых компаниях под фронтендером понимают умение верстать.)
    *   общее представление о расширениях: SASS, LESS, SCSS
*   JS в теории на уровне ES6 а на практике писать изолированные функции и переменные
    *   алгоритмы по учебнику
    *   почему let а не var
    *   event loop
    *   большое О
    *   AJAX, XMLHttpRequest
    *   общее представление о дальнейшем развитии: Typescript, Coffeescript
*   HTML версии 5 на уровне семантической разметки
*   DOM – общее представление и его отображение в объекты JS
*   JSON – формат, типы данных, конвертация из строки в объект и обратно
*   REST
*   Markdown
*   базовые команды для сборки проекта: npm, yarn, webpack, package.json
*   git
    *   знать и командную строку и диалог в IDE
    *   как комитить и пушить, зачем в нём отдельно commit и push
    *   чем отличается pull от fetch, почему за pull ругают
    *   как создать ветку, как смержить ветку
    *   как писать правильные комментарии
    *   как привязывать к задачам в трекере
*   github
    *   как поместить свой ключ и сделать git clone по ключу

Мидл
----

Буквальный перевод слова middle — «середина», но на самом деле в разработке мидл ближе к сеньору, чем к джуну.

В двух словах мидл это кому говорят “**Сделай это, вот идеи как подступиться**".

Разработчик, который в принципе может решить любую задачу самостоятельно. Чаще всего уже знает под десяток языков, перепробовал сотню либ и фреймворков и написал пять своих, потому что всё ещё считает программирование самым важным этапом разработки. Отличный юнит в любую команду, потому что кодить уже умеет, а по зарплате пока не зажрался. Однако, по причине пока еще небольшого опыта, отличается от сеньора уровнем понимания задачи. То есть миддл почти на любую задачу говорит «да, я могу это сделать», но пока не может сказать «нет, давайте не будем так делать».

**Он уже знает и уже умеет, но не знает куда грести**.

**Самое важное на данном этапе:** перестать дрочить код и начать понимать бизнес-требования.  
**Продолжительность:** 3-5 лет.  
**Книги:** Фаулер «[**Рефакторинг**](https://www.google.com/search?newwindow=1&client=safari&rls=en&ei=6mk7XPCrJYa3kwWq7r2IDA&q=%D1%84%D0%B0%D1%83%D0%BB%D0%B5%D1%80+%D1%80%D0%B5%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%BD%D0%B3&oq=%D1%84%D0%B0%D1%83%D0%BB%D0%B5%D1%80+%D1%80%D0%B5%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%BD%D0%B3)». «[**Банда Четырех**](https://www.google.com/search?client=safari&rls=en&q=%D0%B1%D0%B0%D0%BD%D0%B4%D0%B0+%D1%87%D0%B5%D1%82%D1%8B%D1%80%D0%B5%D1%85+%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B&ie=UTF-8&oe=UTF-8)». «[**Программист Прагматик**](https://www.google.com/search?newwindow=1&client=safari&rls=en&ei=I2o7XIv5CKzjsAf0noYQ&q=%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82+%D0%BF%D1%80%D0%B0%D0%B3%D0%BC%D0%B0%D1%82%D0%B8%D0%BA&oq=%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82+%D0%BF%D1%80%D0%B0%D0%B3%D0%BC%D0%B0%D1%82%D0%B8%D0%BA)». Всё остальное, что гуглится по запросу «10 лучших книг для программиста». От себя рекомендую читать книги, углубляющие в отдельные области — по сетям, например, «[**Олифер Олифер Компьютерные Сети**](https://www.google.com/search?client=safari&rls=en&q=%D0%9E%D0%BB%D0%B8%D1%84%D0%B5%D1%80+%D0%9E%D0%BB%D0%B8%D1%84%D0%B5%D1%80+%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D1%8B%D0%B5+%D0%A1%D0%B5%D1%82%D0%B8&ie=UTF-8&oe=UTF-8)», по шифрованию — «[**Книга Шифров**](https://www.google.com/search?client=safari&rls=en&q=%D0%9A%D0%BD%D0%B8%D0%B3%D0%B0+%D0%A8%D0%B8%D1%84%D1%80%D0%BE%D0%B2&ie=UTF-8&oe=UTF-8)», итд в зависимости от ваших интересов.

Для фронта он должен знать:

*   все разновидности бравзеров и их движков, в т.ч. мобильных, их отличия
    *   уметь дебажить CSS и JS
    *   уметь настроить нужные расширения бравзера и бэкенд с map-файлами
*   все актуальные на сегодня селекторы CSS и единицы измерения
    *   хорошо знать один из препроцессоров: SASS или LESS
*   JS ES6 на практике
    *   уметь писать модули
    *   понимать что такое прототипы и почему JS это прототипно-ориентированный язык
    *   уметь в ООП, как писать классы до появления class keyword, и как после.
    *   знать все разновидности записи функций и их особенности
*   хорошо знает один из фреймфорков: Vue,js, React.js, Angular
*   формат YAML синтаксис и правила
*   сетевой протокол GraphQL – хотя бы общие принципы
*   git – тонкости и хитрости, например как бесследно удалить файл или как заменить емейл коммиттера во всех его коммитах
*   github – всё что кроме git – issues, PRs, Wiki, Pages
    *   или что-то другое кроме github – gitlab, bitbucket
*   ws – как работать с вебсокетами в чистом JS и во фреймворке
*   [CSRF](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D0%BB%D0%BA%D0%B0_%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0) – принципы, вектора атак и прочая безопасность
*   [CSP](https://en.wikipedia.org/wiki/Content_Security_Policy) и правила его описания
*   [semver](https://semver.org/lang/ru/) и что значат эти значки

знать ответы на этот тест (что выведет каждый console.log) и почему он выведет это а не иное
```javascript
    a = {}
    if (a === {}) { // разные ссылки - false
      var a = 123
    }
    console.log(a) // {}
    console.log(String(a)) // [object Object]
    console.log(typeof a) // object
    ////////////////////////////////////////////////////////////
    
    const c = {name: 'zzz'}
    const b = {
      [c]: 1 // скобки это не массив а такая запись переменной
    }
    // ключ [c] преобразуется в строку [object Object]
    b[{}] = 2 // здесь ключ тот же самый и значение перепишется
    console.log(b[c]) // 2
    // в массиве не может быть ключа-объекта, а в Map может.
    ////////////////////////////////////////////////////////////
    
    function getPersonInfo(one, two, three) {
      console.log(one);
      console.log(two);
      console.log(three);
      // также можно
      console.log(arguments[0]);
      console.log(arguments[1]);
      console.log(arguments[2]);
    }
    const person = "Lydia";
    const age = 21;
    getPersonInfo`${person} is ${age} years old`;
    // это называется Template literal
    // вызов функции называется Tagged template
    // [ '', ' is ', ' years old' ]
    // Lydia
    // 21
    ////////////////////////////////////////////////////////////
    
    class Car {
      step = 0
    
      upStep () { // обычный метод, this можно сменить
        this.step++
      }
    
      clearStep = () => { // стрелочная, this всегда принадлежит Car
        this.step = 0
      }
    }
    
    Car.prototype.getStep = () => { // this принадлежит window а не Car
      return this.step
    }
    
    const car = new Car()
    car.upStep()
    console.log(car.step) // 1
    console.log(car.getStep()) // undefined
    car.clearStep()
    console.log(car.step) // 0
    ////////////////////////////////////////////////////////////
    
    new Promise(res => res())
      .then(() => {
        throw new Error('Ошибка')
        console.log(2)
      })
      .catch(err => {
        console.log(1)
        throw err
      })
      .then(() => console.log(3))
      .catch(() => console.log(4))
      .then(() => console.log(5))
      .catch(() => console.log(6))
    
    // 1 4 5
    ////////////////////////////////////////////////////////////
    
    const o = {};
    const a = [];
    const d = new Date();
    const n = null;
    
    console.log(o == a); // false
    console.log(o === a); // false
    console.log(typeof o == typeof a); // true (object=object)
    console.log(typeof o === typeof a); // true (object=object)
    console.log(typeof d === typeof a); // true (object=object)
    console.log(typeof n === typeof a); // true (object=object)
    console.log(typeof NaN); // number
    console.log(d instanceof Date); // true
    console.log(d instanceof Object); // true
    console.log(a instanceof Array); // true
    console.log(a instanceof Object); // true
    console.log(typeof (() => {})) // function
    ////////////////////////////////////////////////////////////
```
### Высокий мидл

Иногда бывает так что мидлы сильно отличаются друг от друга, поэтому некоторые предлагают ввести новую категорию – сильный, или высокий мидл. Промежуточный уровень между мидлом и сеньором. Предыдущий мидл можно назвать вялым или низким.

Сильный мидл — это почти сеньор. **Он уже автономен, но ему не хватает софт-скиллов, либо наоборот.**

В двух словах высокий мидл это крутой программист, которому почему-то не дают сеньора.

Для фронта он должен знать:

*   всяческие надстройки над фреймворками: next.js, nuxt.js, quasar, react native
*   как работает oAuth, JWT токены
*   что такое SSR, PWA, уметь собрать сайт как мобильное приложение
*   основные принципы хорошего UI/UX

Сеньор
------

Автономный персонаж с опытом, личной экспертизой и софт-скиллами. Побывал во многих компаниях и лично пожил на разных стадиях эволюций. Программирование для него давно уже не искусство, а скорее сборка конструктора из известных блоков.

В двух словах сеньор это кому говорят “**Сделай это заебись, скажи когда готово**".

В глубине душие сеньора уже заебало все это айти, но он спокоен, прокачал софт-скиллы и понимание того, что многие задачи можно решать вообще без кода.

Во многих бедных странах где процветает Айти-аутсорс, слово “сеньор” превратилось в лычку, как в армии, которую дают за заслуги. «Это важный для нас заказчик, вот закончишь проект — официально дадим тебе сеньора». Нет. Сеньор это не звание а набор качеств и степень зрелости человека как инженера. А мы все знаем, что почему-то зрелость приходит не по моточасам, проведенным за компьютером, и не с количеством проектов, а с годами. Да и то не всегда. Мудрость приходит к старости, но сама старость нисколько не означает мудрость.

Джун знает, миддл умеет, а сеньор имеет опыт. Он больше фокусируется на тактике и вопросах «зачем мы это делаем», а не «какой бы нам фреймворк взять». Ему насрать на код. Сочетает софт и хард скиллы в равных долях.

Сеньор делает хорошо сразу, а мидл делает сперва быстро чтобы работало, а потом рефакторит. Также сеньор следит чтобы младшие делали хорошо.

Фишка в том, что не всем нужны сеньоры. Большинство задач в современном айти не требуют опыта вообще. Мидлы получаются выгоднее.

**Самое важное (и сложное) для левелапа:** понять что дальше.  
**Продолжительность:** сколько угодно.  
**Книги:** любые НЕ по программированию.

Для фронта он должен знать:

*   какой язык и фреймворк лучше всего подходит для этого бизнеса, этой команды и этого проекта
*   чем отличаются разные версии nodejs, какая лучше подходит в данном случае
*   docker и контейнеры, уметь поднять проект на любом окружении
*   стартануть проект с нуля, выбрать оптимальные технологии
*   документировать:
    *   писать техническую документацию с правилами работы
    *   писать функциональную документацию
    *   разбивать её на истории
    *   разбивать историю на таски
*   оценивать таски по градациям сложности
    *   знать такие системы оценок как [ICE](https://habr.com/ru/company/hygger/blog/422131/), [RICE](https://www.intercom.com/blog/rice-simple-prioritization-for-product-managers/)
    *   выявлять те таски которые занимают много времени и разбивать их на мелкие
    *   выявлять те таски которые лучше не делать на данной итерации
*   быть [data driven](https://habr.com/ru/post/158277/) и уметь покрывать метриками ВСЁ – каждый чих юзера и каждый пук сайта

Тимлид, техлид и прочие
-----------------------

_Самый главный навык, который позволит оставаться на плаву в айти, менеджменте, да вообще хоть где — это умение решать проблемы._  
  
_Не умение писать код или закрывать таски. Не знание ебучей тучи алгоритмов. Не сертификаты скрам-мастера десятого левела. Не использование табов вместо пробелов. Именно умение взять реальную проблему и самому её блять решить — вот главный навык профессионала. Самому не значит в одиночку. Самому — значит уметь найти необходимые ресурсы, поднять людей, поставить задачи, проконтролировать результат и нести за всё это личную ответственность. Вот такие люди будут нужны всегда, в любой сфере и в любом возрасте. Вот к чему надо стремиться — тогда никогда не будет проблем ни с самоопределением, ни с зарплатой._

_Примечание: между «решать проблемы» и «форспушить в мастер в три часа ночи» есть тонкая грань. Любой совет можно довести до крайности, но зачем?_